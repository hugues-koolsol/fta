src_javascript(
   (file_name , core1),
   (file_extension , js),
   (file_path , .),
   (strict()),
   source(
      #(
         =============================================
         =============================================
         =============================================
         fonction transforme un texte pour qu'il  soit 
         visible en html, par exemple &nbsp; ou bien <
         =============================================
         =============================================
         =============================================
      ),
      fonction(
         definition(
            nom(traiteCommentaireSourceEtGenere1),
            argument(texte),
            argument(niveau),
            argument(ind),
            argument(nbEspacesSrc1),
            argument(fichierRev0)
         ),
         contenu(
            declare(i , 0),
            #(Si c'est un commentaire monoligne, on le retourne sans aucune transformation),
            affecte(i , appelf(element(texte) , n(indexOf) , p('\n'))),
            choix(
               si(condition(infeg(tab.length , 1)) , alors(revenir(texte)))
            ),
            #(),
            declare(i , 0),
            declare(j , 0),
            declare(l01 , 0),
            declare(min , 0),
            declare(t , ''),
            declare(ligne , ''),
            declare(temps , ''),
            declare(newTab , appelf(n(Array))),
            declare(tab , appelf(n(Array))),
            affecte(tab , appelf(element(texte) , n(split) , p('\n'))),
            affecte(l01 , tab.length),
            #(),
            choix(
               si(
                  condition(sup(texte.length , 1)),
                  alors(
                     affecte(ligne , appelf(element(texte) , n(substr) , p(0) , p(1))),
                     choix(
                        si(
                           condition(egal(ligne , '#')),
                           alors(
                              #(
                                 on a un commentaire de type bloc non formaté 
                                 car le premier caractère = #
                              ),
                              #(
                                 si on traite un source de type rev,
                                 on ne transforme pas le texte ...
                              ),
                              choix(
                                 si(condition((fichierRev0)) , alors(revenir(texte)))
                              ),
                              #(
                                 ... sinon on supprime les espaces 
                                 inutiles en début de ligne.
                              ),
                              affecte(t , ''),
                              affecte(min , 99999),
                              boucle(
                                 initialisation(affecte(i , 0)),
                                 condition(inf(i , l01)),
                                 increment(affecte(i , i+1)),
                                 faire(
                                    affecte(ligne , tab[i]),
                                    boucle(
                                       initialisation(affecte(j , 0)),
                                       condition(inf(j , ligne.length)),
                                       increment(affecte(j , j+1)),
                                       faire(
                                          #(
                                             on balaye toutes les lignes pour détecter 
                                             le nombre d'espaces minimal à gauche
                                          ),
                                          affecte(temps , appelf(element(ligne) , n(substr) , p(j) , p(1))),
                                          choix(
                                             si(condition(egal(temps , ' ')) , alors(continue())),
                                             sinon(
                                                alors(
                                                   choix(
                                                      si(
                                                         condition(inf(j , min)),
                                                         alors(
                                                            #(on réajuste le minimum),
                                                            affecte(min , j)
                                                         )
                                                      )
                                                   ),
                                                   #( et on passe à la ligne suivante),
                                                   break()
                                                )
                                             )
                                          )
                                       )
                                    )
                                 )
                              ),
                              choix(
                                 si(
                                    condition(sup(min , 0)),
                                    alors(
                                       boucle(
                                          initialisation(affecte(i , 1)),
                                          condition(inf(i , l01)),
                                          increment(affecte(i , i+1)),
                                          faire(
                                             affecte(tab[i] , appelf(element(tab[i]) , n(substr) , p(min)))
                                          )
                                       ),
                                       affecte(texte , appelf(element(tab) , n(join) , p('\n')))
                                    )
                                 )
                              ),
                              revenir(texte)
                           )
                        )
                     )
                  )
               )
            ),
            #(
               si on est ici, c'est qu'on a un commentaire multiligne
               qu'il faut formatter en alignant à gauche les textes 
               d'un nombre d'espaces correspondant au niveau
            )
         )
      ),
      #(
         =============================================
         =============================================
         =============================================
         fonction transforme un texte pour qu'il  soit 
         visible en html, par exemple &nbsp; ou bien <
         =============================================
         =============================================
         =============================================
      ),
      fonction(
         definition(nom(strToHtml) , argument(s)),
         contenu(
            declare(
               r1,
               new(appelf(n(RegExp) , p('&') , p('g')))
            ),
            declare(
               r2,
               new(appelf(n(RegExp) , p('<') , p('g')))
            ),
            declare(
               r3,
               new(appelf(n(RegExp) , p('>') , p('g')))
            ),
            affecte(s , appelf(n(replace) , element(s) , p(r1) , p('&amp;'))),
            affecte(s , appelf(n(replace) , element(s) , p(r2) , p('&lt;'))),
            affecte(s , appelf(n(replace) , element(s) , p(r3) , p('&gt;'))),
            revenir(s)
         )
      ),
      #(
         =================================================
         =================================================
         =================================================
         fonction qui reconstitue un texte source à partir  
         du tableau représentant la matrice  du  programme
         =================================================
         =================================================
         =================================================
      ),
      fonction(
         definition(
            nom(a2F1),
            argument(arr),
            argument(parentId),
            argument(retourLigne),
            argument(debut),
            argument(coloration)
         ),
         contenu(
            #(
               ========================================
               Attention : cette fonction est récursive
               ========================================
            ),
            declare(i , 0),
            declare(j , 0),
            declare(obj , obj()),
            declare(t , ''),
            declare(profondeurLimite , 3),
            declare(nombreEnfantsLimite , 3),
            declare(forcerRetourLigne , faux),
            declare(condition1 , faux),
            declare(commentaire , ''),
            declare(l01 , 0),
            affecte(l01 , arr.length),
            #(
               =====================================================================
               boucle principale qui commence à partir de "debut" passé en paramètre
               =====================================================================
            ),
            boucle(
               initialisation(affecte(i , debut)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  #(
                     on ne traite que les enfants et les éléments 
                     dont le niveau est supérieur au niveau du parent
                  ),
                  choix(
                     si(
                        condition((egal(arr[i][7] , parentId))),
                        alors(
                           #(On va à la suite du programme)
                        )
                     ),
                     sinonsi(
                        condition((infeg(arr[i][3] , arr[parentId][3]))),
                        alors(break())
                     ),
                     sinon(
                        alors(
                           #(
                              on va dans la ligne suivante de la matrice 
                              et on ne fait pas le traitement ci dessous 
                           ),
                           continue()
                        )
                     )
                  ),
                  #(
                     On doit forcer le retour de ligne quand la
                     profondeur est trop importante ou bien
                     qu'il y a trop d'enfants ou bien qu'il
                     y a des commentaires
                  ),
                  choix(
                     si(
                        condition((egal(retourLigne , vrai)) , et(sup(arr[parentId][10] , profondeurLimite))),
                        alors(affecte(forcerRetourLigne , vrai))
                     ),
                     sinonsi(
                        condition(
                           (egal(retourLigne , vrai)),
                           et(
                              #(le type du parent est une fonction ou bien c'est la racine),
                              (egal(arr[parentId][2] , 'f')),
                              ou(egal(arr[parentId][2] , 'INIT'))
                           )
                        ),
                        alors(
                           #(
                              Si c'est la premier enfant d'une fonction, 
                              on teste si il existe des enfants de type commentaires
                           ),
                           boucle(
                              initialisation(affecte(j , debut)),
                              condition((inf(j , l01)) , et(sup(arr[j][3] , arr[parentId][3]))),
                              increment(affecte(j , j+1)),
                              faire(
                                 choix(
                                    si(
                                       condition((egal(arr[j][1] , DEBUTCOMMENTAIRE)) , et(egal(arr[j][2] , 'f')) , et(inf(arr[j][3] , arr[parentId][3]+profondeurLimite))),
                                       alors(
                                          #(
                                             il y a un commentaire
                                             c'est une fonction
                                             niveau inférieur à celui du parent + profondeur limite
                                          ),
                                          affecte(forcerRetourLigne , vrai),
                                          break()
                                       )
                                    )
                                 )
                              )
                           ),
                           boucle(
                              initialisation(affecte(j , debut)),
                              condition((inf(j , l01)) , et(sup(arr[j][3] , arr[parentId][3]))),
                              increment(affecte(j , j+1)),
                              faire(
                                 choix(
                                    si(
                                       condition((sup(arr[j][8] , nombreEnfantsLimite))),
                                       alors(
                                          #(
                                             si le nombre d'enfants est supérieur à 3
                                          ),
                                          affecte(forcerRetourLigne , vrai),
                                          break()
                                       )
                                    )
                                 )
                              )
                           )
                        )
                     )
                  ),
                  #(
                     ici la variable forcerRetourLigne est éventuellement mise à true 
                  ),
                  affecte(
                     condition1,
                     condition((egal(arr[parentId][2] , 'f')) , et(infeg(arr[parentId][8] , nombreEnfantsLimite)) , et(infeg(arr[parentId][10] , profondeurLimite)))
                  ),
                  choix(
                     si(
                        condition((sup(arr[i][9] , 1))),
                        alors(
                           #(!forcerRetourLigne && retourLigne==true && condition1),
                           choix(
                              si(
                                 condition(non(forcerRetourLigne) , et(egal(retourLigne , true)) , et(condition1)),
                                 alors(
                                    affecte(t , appelf(n(concat) , p(t) , p(' , ')))
                                 )
                              ),
                              sinon(
                                 alors(
                                    affecte(t , appelf(n(concat) , p(t) , p(',')))
                                 ),
                                 #(finsinon)
                              )
                           )
                        )
                     )
                  ),
                  choix(
                     si(
                        condition(
                           (((forcerRetourLigne)) , et(diff(arr[parentId][2] , 'INIT')))
                        ),
                        alors(
                           appelf(
                              r(t),
                              n(concat),
                              p(t),
                              p(appelf(n(espacesnrev) , p(false) , p(arr[i][3])))
                           )
                        )
                     ),
                     sinonsi(
                        condition((retourLigne)),
                        alors(
                           choix(
                              si(
                                 condition(
                                    ((egal(arr[parentId][2] , 'INIT')) , et(egal(arr[i][9] , 1))),
                                    ou(condition1)
                                 ),
                                 alors(
                                    #(on ne fait rien)
                                 )
                              ),
                              sinon(
                                 alors(
                                    appelf(
                                       r(t),
                                       n(concat),
                                       p(t),
                                       p(appelf(n(espacesnrev) , p(false) , p(arr[i][3])))
                                    )
                                 )
                              )
                           )
                        )
                     )
                  ),
                  #(
                     ======================================
                     ici, forcerRetourLigne est vrai ou pas
                     ======================================
                     si  on  doit  traiter  une  constante
                     ======================================
                  ),
                  choix(
                     si(
                        condition((egal(arr[i][2] , 'c'))),
                        alors(
                           choix(
                              si(
                                 condition(((coloration))),
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(arr[i][4] , true))),
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p('\''),
                                                p(appelf(n(strToHtml) , p(arr[i][1]))),
                                                p('\'')
                                             )
                                          )
                                       ),
                                       sinon(
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p(appelf(n(strToHtml) , p(arr[i][1])))
                                             )
                                          ),
                                          #(finsinon)
                                       )
                                    )
                                 )
                              ),
                              sinon(
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(arr[i][4] , true))),
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p('\''),
                                                p(arr[i][1]),
                                                p('\'')
                                             )
                                          )
                                       ),
                                       sinon(
                                          alors(appelf(r(t) , n(concat) , p(t) , p(arr[i][1]))),
                                          #(finsinon)
                                       )
                                    )
                                 )
                              )
                           ),
                           continue()
                        )
                     )
                  ),
                  #(
                     
                     
                     ===================================================
                     si on doit traiter une fonction de type commentaire
                     ===================================================            
                  ),
                  choix(
                     si(
                        condition((egal(arr[i][2] , 'f')) , et(egal(arr[i][1] , DEBUTCOMMENTAIRE))),
                        alors(
                           #(
                              ==========================
                              on est dans un commentaire
                              ==========================
                           ),
                           affecte(commentaire , appelf(n(ttcomm1) , p(arr[i][13]) , p(arr[i][3]) , p(i))),
                           choix(
                              si(
                                 condition(((coloration))),
                                 alors(
                                    #(mise en forme en HTML),
                                    appelf(r(commentaire) , n(strToHtml) , p(commentaire)),
                                    choix(
                                       si(
                                          condition(((retourLigne))),
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p('<span '),
                                                p('style="'),
                                                p('color:darkgreen;'),
                                                p('background-color:lightgrey;'),
                                                p('"'),
                                                p('>'),
                                                p(appelf(n(strToHtml) , p(arr[i][1]))),
                                                p('('),
                                                p(commentaire),
                                                p(')'),
                                                p('</span>')
                                             )
                                          )
                                       ),
                                       sinon(
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p('<span '),
                                                p('style="'),
                                                p('color:darkgreen;'),
                                                p('background-color:lightgrey;'),
                                                p('"'),
                                                p('>'),
                                                p(appelf(n(strToHtml) , p(arr[i][1]))),
                                                p('('),
                                                p(')'),
                                                p('</span>')
                                             )
                                          )
                                       )
                                    )
                                 )
                              ),
                              sinon(
                                 alors(
                                    #(pas de mise en forme en HTML),
                                    choix(
                                       si(
                                          condition(((retourLigne))),
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p(arr[i][1]),
                                                p('('),
                                                p(commentaire),
                                                p(')')
                                             )
                                          )
                                       ),
                                       sinon(
                                          alors(appelf(r(t) , n(concat) , p(t) , p(arr[i][1]) , p('()')))
                                       )
                                    )
                                 )
                              )
                           ),
                           continue()
                        )
                     )
                  ),
                  #(
                     
                     
                     ===========================================================
                     pour toutes les autres fonctions, on fait un appel récursif
                     ===========================================================    
                  ),
                  declare(obj , obj()),
                  appelf(
                     r(obj),
                     n(a2F1),
                     p(arr),
                     p(i),
                     p(retourLigne),
                     p(i+1),
                     p(coloration)
                  ),
                  choix(
                     si(
                        condition(
                           ((egalstricte(obj.status , vrai)))
                        ),
                        alors(
                           #(on ajoute le nom de la fonction et on ouvre la parenthèse),
                           choix(
                              si(
                                 condition(((coloration))),
                                 alors(
                                    appelf(
                                       r(t),
                                       n(concat),
                                       p(t),
                                       p(appelf(n(strToHtml) , p(arr[i][1]))),
                                       p('(')
                                    )
                                 )
                              ),
                              sinon(
                                 alors(appelf(r(t) , n(concat) , p(t) , p(arr[i][1]) , p('(')))
                              )
                           ),
                           #(
                              ============================================
                              on ajoute le contenu récursif de la fonction
                              ============================================
                           ),
                           appelf(r(t) , n(concat) , p(t) , p(obj.value)),
                           #(
                              on met les retours de ligne
                           ),
                           choix(
                              si(
                                 condition(
                                    ((forcerRetourLigne) , et(egal(obj.forcerRetourLigne , vrai)))
                                 ),
                                 alors(
                                    appelf(
                                       r(t),
                                       n(concat),
                                       p(t),
                                       p(appelf(n(espacesnrev) , p(faux) , p(arr[i][3])))
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((retourLigne)),
                                 alors(
                                    choix(
                                       si(
                                          condition(
                                             non((infeg(arr[i][8] , nombreEnfantsLimite)) , et(infeg(arr[i][10] , profondeurLimite)))
                                          ),
                                          alors(
                                             appelf(
                                                r(t),
                                                n(concat),
                                                p(t),
                                                p(appelf(n(espacesnrev) , p(faux) , p(arr[i][3])))
                                             )
                                          )
                                       )
                                    )
                                 )
                              )
                           ),
                           #(
                              on ferme la parenthèse
                           ),
                           appelf(r(t) , n(concat) , p(t) , p(')'))
                        )
                     ),
                     sinon(
                        alors(
                           affecte(obj , obj(('status' , faux) , ('message' , 'erreur') , ('id' , i))),
                           revenir(obj)
                        )
                     )
                  )
               )
            ),
            affecte(obj , obj((status , true) , (value , t) , (forcerRetourLigne , forcerRetourLigne))),
            revenir(obj)
         )
      ),
      #(
         
         
         
         
         ===========================================
         ===========================================
         ===========================================
         fonction qui produit un tableau html de  la
         liste des caractères du source du programme
         ===========================================
         ===========================================
         ===========================================
      ),
      fonction(
         definition(nom(ConstruitHtmlTableauCaracteres) , argument(t2) , argument(texteSource) , argument(objTableau)),
         contenu(
            declare(numeroLigne , 0),
            declare(debut , 0),
            declare(i , 0),
            declare(j , 0),
            declare(l01 , 0),
            declare(tmps , ''),
            declare(out , appelf(n(Array))),
            appelf(element(t2) , n(setAttribute) , p('class') , p('tableau2')),
            choix(
               si(
                  condition((egalstricte(objTableau , null))),
                  alors(
                     #(On construit le tableau à partir du texte source),
                     declare(outo , obj()),
                     appelf(r(outo) , n(iterateCharacters2) , p(texteSource)),
                     affecte(out , outo.out)
                  )
               ),
               sinon(alors(affecte(out , objTableau.out)))
            ),
            #(
               première case du tableau = numéro de ligne
            ),
            declare(tr1 , obj()),
            declare(td1 , obj()),
            appelf(r(tr1) , n(document.createElement) , p('tr')),
            appelf(r(td1) , n(document.createElement) , p('td')),
            affecte(td1.innerHTML , numeroLigne),
            appelf(element(tr1) , n(appendChild) , p(td1)),
            #(boucle principale),
            affecte(l01 , out.length),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  declare(td1 , obj()),
                  appelf(r(td1) , n(document.createElement) , p('td')),
                  appelf(r(td1.innerHTML) , element(out[i][0]) , n(replace) , p('\n') , p('\\n')),
                  appelf(r(tmps) , element(out[i][0]) , n(codePointAt) , p(0)),
                  appelf(
                     r(td1.title),
                     n(concat),
                     p('&amp;#'),
                     p(tmps),
                     p('; ('),
                     p(out[i][1]),
                     p(')')
                  ),
                  appelf(element(tr1) , n(appendChild) , p(td1)),
                  #(
                     ============================================
                     Si on a un retour chariot, on écrit les 
                     cases contenant les positions des caractères
                     ============================================
                  ),
                  choix(
                     si(
                        condition((egal(out[i][0] , '\n'))),
                        alors(
                           appelf(element(t2) , n(appendChild) , p(tr1)),
                           #(
                              
                              
                              =================================================
                              indice dans tableau = première ligne des chiffres
                              =================================================
                           ),
                           declare(tr1 , obj()),
                           declare(td1 , obj()),
                           appelf(r(tr1) , n(document.createElement) , p('tr')),
                           appelf(r(td1) , n(document.createElement) , p('td')),
                           appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
                           affecte(td1.innerHTML , '&nbsp;'),
                           appelf(element(tr1) , n(appendChild) , p(td1)),
                           boucle(
                              initialisation(affecte(j , debut)),
                              condition(inf(j , i)),
                              increment(affecte(j , j+1)),
                              faire(
                                 declare(td1 , obj()),
                                 appelf(r(td1) , n(document.createElement) , p('td')),
                                 choix(
                                    si(
                                       condition((egal(out[j][1] , 1))),
                                       alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td2')))
                                    ),
                                    sinon(
                                       alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td4')))
                                    )
                                 ),
                                 affecte(td1.innerHTML , j),
                                 appelf(element(tr1) , n(appendChild) , p(td1))
                              )
                           ),
                           #(
                              
                              =====================
                              position du backslash
                              =====================
                           ),
                           declare(td1 , obj()),
                           appelf(r(td1) , n(document.createElement) , p('td')),
                           appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
                           affecte(td1.innerHTML , j),
                           appelf(element(tr1) , n(appendChild) , p(td1)),
                           appelf(element(t2) , n(appendChild) , p(tr1)),
                           #(
                              
                              ========================================================
                              position dans la chaine = deuxième ligne des chiffres
                              car certains caractères utf8 sont codées sur 2 positions
                              ========================================================
                           ),
                           declare(tr1 , obj()),
                           declare(td1 , obj()),
                           appelf(r(tr1) , n(document.createElement) , p('tr')),
                           appelf(r(td1) , n(document.createElement) , p('td')),
                           appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
                           affecte(td1.innerHTML , '&nbsp;'),
                           appelf(element(tr1) , n(appendChild) , p(td1)),
                           boucle(
                              initialisation(affecte(j , debut)),
                              condition(inf(j , i)),
                              increment(affecte(j , j+1)),
                              faire(
                                 declare(td1 , obj()),
                                 appelf(r(td1) , n(document.createElement) , p('td')),
                                 choix(
                                    si(
                                       condition((egal(out[j][1] , 1))),
                                       alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td2')))
                                    ),
                                    sinon(
                                       alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td4')))
                                    )
                                 ),
                                 affecte(td1.innerHTML , out[j][2]),
                                 appelf(element(tr1) , n(appendChild) , p(td1))
                              )
                           ),
                           #(
                              
                              =====================
                              position du backslash
                              =====================
                           ),
                           declare(td1 , obj()),
                           appelf(r(td1) , n(document.createElement) , p('td')),
                           appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
                           affecte(td1.innerHTML , out[j][3]),
                           appelf(element(tr1) , n(appendChild) , p(td1)),
                           appelf(element(t2) , n(appendChild) , p(tr1)),
                           #(
                              
                              
                              ======================================
                              fin des lignes contenant les positions
                              ======================================
                           ),
                           affecte(debut , i+1),
                           affecte(numeroLigne , numeroLigne+1),
                           declare(tr1 , obj()),
                           declare(td1 , obj()),
                           appelf(r(tr1) , n(document.createElement) , p('tr')),
                           appelf(r(td1) , n(document.createElement) , p('td')),
                           affecte(td1.innerHTML , numeroLigne),
                           appelf(element(tr1) , n(appendChild) , p(td1)),
                           appelf(element(t2) , n(appendChild) , p(tr1)),
                           #(
                              ============================================
                              FIN Si on a un retour chariot, on écrit les 
                              cases contenant les positions des caractères
                              ============================================
                           )
                        )
                     )
                  ),
                  #(dernière ligne de faire boucle)
               )
            ),
            #(
               dernière ligne des positions des caractères
            ),
            appelf(element(t2) , n(appendChild) , p(tr1)),
            #(
               
               
               =================================================
               indice dans tableau = première ligne des chiffres
               =================================================
            ),
            declare(tr1 , obj()),
            declare(td1 , obj()),
            appelf(r(tr1) , n(document.createElement) , p('tr')),
            appelf(r(td1) , n(document.createElement) , p('td')),
            appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
            affecte(td1.innerHTML , '&nbsp;'),
            appelf(element(tr1) , n(appendChild) , p(td1)),
            boucle(
               initialisation(affecte(j , debut)),
               condition(inf(j , i)),
               increment(affecte(j , j+1)),
               faire(
                  declare(td1 , obj()),
                  appelf(r(td1) , n(document.createElement) , p('td')),
                  choix(
                     si(
                        condition((egal(out[j][1] , 1))),
                        alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td2')))
                     ),
                     sinon(
                        alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td4')))
                     )
                  ),
                  affecte(td1.innerHTML , j),
                  appelf(element(tr1) , n(appendChild) , p(td1)),
                  #(finchoix suite du source)
               )
            ),
            appelf(element(t2) , n(appendChild) , p(tr1)),
            #(
               =====================
               pas de position du backslash
               =====================
            ),
            #(
               =====================================================
               position dans la chaine = deuxième ligne des chiffres
               =====================================================
            ),
            declare(tr1 , obj()),
            declare(td1 , obj()),
            appelf(r(tr1) , n(document.createElement) , p('tr')),
            appelf(r(td1) , n(document.createElement) , p('td')),
            appelf(element(td1) , n(setAttribute) , p('class') , p('td2')),
            affecte(td1.innerHTML , '&nbsp;'),
            appelf(element(tr1) , n(appendChild) , p(td1)),
            boucle(
               initialisation(affecte(j , debut)),
               condition(inf(j , i)),
               increment(affecte(j , j+1)),
               faire(
                  declare(td1 , obj()),
                  appelf(r(td1) , n(document.createElement) , p('td')),
                  choix(
                     si(
                        condition((egal(out[j][1] , 1))),
                        alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td2')))
                     ),
                     sinon(
                        alors(appelf(element(td1) , n(setAttribute) , p('class') , p('td4')))
                     )
                  ),
                  affecte(td1.innerHTML , out[j][2]),
                  appelf(element(tr1) , n(appendChild) , p(td1)),
                  #(finchoix suite du source)
               )
            ),
            #(et enfin, on ajoute la dernière ligne),
            appelf(element(t2) , n(appendChild) , p(tr1))
         )
      ),
      #(
         ==========================================
         ==========================================
         ==========================================
         fonction qui produit un tableau html de la
         forme matricielle du programme
         ==========================================
         ==========================================
         ==========================================
      ),
      fonction(
         definition(nom(ConstruitHtmlMatrice) , argument(t1) , argument(matriceFonction)),
         contenu(
            #(),
            declare(i , 0),
            declare(j , 0),
            declare(l01 , 0),
            declare(temp , ''),
            declare(tr1 , obj()),
            declare(td1 , obj()),
            declare(
               r1,
               new(appelf(n(RegExp) , p(' ') , p('g')))
            ),
            declare(
               r2,
               new(appelf(n(RegExp) , p('\n') , p('g')))
            ),
            appelf(r(tr1) , n(document.createElement) , p('tr')),
            #(
               =================
               entête du tableau
               =================
            ),
            affecte(l01 , global_enteteTableau.length),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  declare(td1 , obj()),
                  appelf(r(td1) , n(document.createElement) , p('td')),
                  affecte(td1.innerHTML , appelf(n(concat) , p(i) , p(global_enteteTableau[i][0]))),
                  #(#                  td1.setAttribute('title',global_enteteTableau[i][1] + '(' + i + ')');),
                  appelf(
                     element(td1),
                     n(setAttribute),
                     p('title'),
                     p(appelf(n(concat) , p(global_enteteTableau[i][1]) , p('(') , p(i) , p(')')))
                  ),
                  appelf(element(tr1) , n(appendChild) , p(td1))
               )
            ),
            appelf(element(t1) , n(appendChild) , p(tr1)),
            #(
               
               
               ===================
               éléments du tableau
               ===================
            ),
            affecte(l01 , matriceFonction.value.length),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  declare(tr1 , obj()),
                  appelf(r(tr1) , n(document.createElement) , p('tr')),
                  boucle(
                     initialisation(affecte(j , 0)),
                     condition(inf(j , matriceFonction.value[i].length)),
                     increment(affecte(j , j+1)),
                     faire(
                        declare(td1 , obj()),
                        appelf(r(td1) , n(document.createElement) , p('td')),
                        choix(
                           si(
                              condition((egal(j , 1)) , ou(egal(j , 13))),
                              alors(
                                 #(Pour la valeur ou les commentaires),
                                 affecte(temp , appelf(n(String) , p(matriceFonction.value[i][j]))),
                                 affecte(temp , appelf(n(replace) , element(temp) , p(r1) , p('░'))),
                                 affecte(temp , appelf(n(replace) , element(temp) , p(r2) , p('¶'))),
                                 affecte(td1.innerHTML , temp),
                                 affecte(td1.style.whiteSpace , 'pre-wrap'),
                                 affecte(td1.style.verticalAlign , 'baseline')
                              )
                           ),
                           sinonsi(
                              condition((egal(j , 4))),
                              alors(
                                 #(si la Constante est quotée),
                                 choix(
                                    si(
                                       condition((egal(matriceFonction.value[i][j] , true))),
                                       alors(affecte(td1.innerHTML , '1'))
                                    ),
                                    sinon(alors(affecte(td1.innerHTML , '')))
                                 )
                              )
                           ),
                           sinon(
                              alors(
                                 affecte(td1.innerHTML , appelf(n(String) , p(matriceFonction.value[i][j])))
                              )
                           )
                        ),
                        affecte(temp , appelf(n(concat) , p(global_enteteTableau[j][1]) , p('(') , p(j) , p(')'))),
                        appelf(element(td1) , n(setAttribute) , p('title') , p(temp)),
                        appelf(element(tr1) , n(appendChild) , p(td1))
                     )
                  ),
                  appelf(element(t1) , n(appendChild) , p(tr1))
               )
            )
         )
      ),
      #(
         ===========================================
         ===========================================
         ===========================================
         fonction qui transforme un texte en tableau
         ===========================================
         ===========================================
         ===========================================
      ),
      fonction(
         definition(nom(iterateCharacters2) , argument(str)),
         contenu(
            declare(out , appelf(n(Array))),
            declare(i , 0),
            declare(j , 0),
            declare(exceptions , 0),
            declare(numLigne , 0),
            declare(l01 , str.length),
            declare(codeCaractere , ''),
            declare(retour , obj()),
            declare(temp , 0),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  appelf(r(codeCaractere) , element(str) , n(charCodeAt) , p(i)),
                  choix(
                     si(
                        #(
                           zero width space , vertical tab
                        ),
                        condition(
                           non((egalstricte(codeCaractere , 8203)) , ou(egalstricte(codeCaractere , 11)))
                        ),
                        alors(
                           #(
                              0xD800 =55296
                           ),
                           affecte(temp , codeCaractere&0xF800),
                           choix(
                              si(
                                 condition(
                                    ((egalstricte(temp , 55296)))
                                 ),
                                 alors(
                                    appelf(
                                       n(push),
                                       element(out),
                                       p(
                                          appelf(
                                             n(Array),
                                             p(appelf(element(str) , n(substr) , p(i) , p(2))),
                                             p(2),
                                             p(i),
                                             p(numLigne)
                                          )
                                       )
                                    ),
                                    affecte(i , i+1)
                                 )
                              ),
                              sinon(
                                 alors(
                                    appelf(
                                       n(push),
                                       element(out),
                                       p(
                                          appelf(
                                             n(Array),
                                             p(appelf(element(str) , n(substr) , p(i) , p(1))),
                                             p(1),
                                             p(i),
                                             p(numLigne)
                                          )
                                       )
                                    ),
                                    choix(
                                       si(
                                          condition((egalstricte(codeCaractere , 10))),
                                          alors(affecte(numLigne , numLigne+1))
                                       )
                                    )
                                 )
                              )
                           )
                        )
                     ),
                     sinon(alors(affecte(exceptions , exceptions+1)))
                  )
               )
            ),
            affecte(retour , obj(('out' , out) , ('numLigne' , numLigne) , ('exceptions' , exceptions))),
            revenir(retour)
         )
      ),
      #(
         ==================================================
         ==================================================
         ==================================================
         tableau retourné par l'analyse syntaxique 
         du texte en entrée de la fonction functionToArray2
         ==================================================
         ==================================================
         ==================================================
      ),
      declare(
         global_enteteTableau,
         appelf(
            n(Array),
            p(appelf(n(Array) , p('id') , p('id'))),
            p(appelf(n(Array) , p('val') , p('value'))),
            p(appelf(n(Array) , p('typ') , p('type'))),
            p(appelf(n(Array) , p('niv') , p('niveau'))),
            p(appelf(n(Array) , p('coQ') , p('constante quotée'))),
            p(appelf(n(Array) , p('pre') , p('position du premier caractère'))),
            p(appelf(n(Array) , p('der') , p('position du dernier caractère'))),
            p(appelf(n(Array) , p('pId') , p('Id du parent'))),
            p(appelf(n(Array) , p('nbE') , p('nombre d\'enfants'))),
            p(appelf(n(Array) , p('nuE') , p('numéro enfants'))),
            p(appelf(n(Array) , p('pro') , p('profondeur'))),
            p(appelf(n(Array) , p('pop') , p('position ouverture parenthese'))),
            p(appelf(n(Array) , p('pfp') , p('position fermeture parenthese'))),
            p(appelf(n(Array) , p('com') , p('commentaire')))
         )
      ),
      #(
         ===================================================
         ===================================================
         ===================================================
         fonction d'analyse syntaxique d'un programme source
         ===================================================
         ===================================================
         ===================================================
      ),
      fonction(
         definition(
            nom(functionToArray2),
            #(Un tableau contenant le texte source),
            argument(tableauEntree),
            argument(exitOnLevelError)
         ),
         contenu(
            #(
               =========================
               les chaines de caractères
               =========================
            ),
            declare(texte , ''),
            declare(commentaire , ''),
            declare(c , ''),
            declare(c1 , ''),
            declare(c2 , ''),
            #(
               =========================
               les entiers
               =========================
            ),
            declare(i , 0),
            declare(j , 0),
            declare(k , 0),
            declare(l , 0),
            declare(indice , 0),
            declare(niveau , 0),
            declare(premier , 0),
            declare(dernier , 0),
            declare(numeroLigne , 0),
            declare(posOuvPar , 0),
            declare(posFerPar , 0),
            declare(niveauDebutCommentaire , 0),
            declare(niveauDansCommentaire , 0),
            #(
               =========================
               les booléens
               =========================
            ),
            declare(dansCst , false),
            declare(dsComment , false),
            declare(constanteQuotee , false),
            #(
               ====================================
               Le tableau en sortie si tout va bien
               ====================================
            ),
            declare(
               T,
               new(appelf(n(Array)))
            ),
            declare(temp , obj()),
            #(
               =======================================================================
               initialisation du tableau contenant le source structuré en arborescence
               =======================================================================
               0id    1val  2typ  3niv  4coQ
               5pre   6der  7pId  8nbE  9numEnfant  
               10pro 11OPa 12FPa 13comm
            ),
            appelf(
               n(push),
               element(T),
               p(
                  appelf(
                     n(Array),
                     p(0),
                     p(texte),
                     p('INIT'),
                     p(-1),
                     p(constanteQuotee),
                     p(premier),
                     p(dernier),
                     p(0),
                     p(0),
                     p(0),
                     p(0),
                     p(posOuvPar),
                     p(posFerPar),
                     p('')
                  )
               )
            ),
            declare(l01 , tableauEntree.length),
            #(
               // ====================================================================
               // ====================================================================
               // boucle principale sur tous les caractères du texte passé en argument
               // on commence par analyser les cas ou on est dans des chaines, puis on
               // analyse les caractères
               // ====================================================================
               // ====================================================================
            ),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  affecte(c , tableauEntree[i][0]),
                  choix(
                     si(
                        condition((dsComment)),
                        alors(
                           #(
                              
                              
                              
                              =============================
                              Si on est dans un commentaire
                              =============================
                           ),
                           choix(
                              si(
                                 condition((egal(c , ')'))),
                                 alors(
                                    choix(
                                       si(
                                          condition(
                                             ((egal(niveau , niveauDebutCommentaire+1)) , et(egal(niveauDansCommentaire , 0)))
                                          ),
                                          alors(
                                             affecte(posFerPar , i),
                                             affecte(T[T.length-1][13] , commentaire),
                                             affecte(T[T.length-1][12] , posFerPar),
                                             affecte(commentaire , ''),
                                             affecte(dsComment , faux),
                                             affecte(niveau , niveau-1)
                                          )
                                       ),
                                       sinon(
                                          alors(
                                             affecte(commentaire , appelf(n(concat) , p(commentaire) , p(c))),
                                             affecte(niveauDansCommentaire , niveauDansCommentaire-1)
                                          )
                                       )
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , '('))),
                                 alors(
                                    affecte(commentaire , appelf(n(concat) , p(commentaire) , p(c))),
                                    affecte(niveauDansCommentaire , niveauDansCommentaire+1)
                                 )
                              ),
                              sinon(
                                 alors(
                                    affecte(commentaire , appelf(n(concat) , p(commentaire) , p(c)))
                                 )
                              )
                           ),
                           #(
                              =============================
                              FIN de Si on est dans un commentaire
                              =============================
                              
                              
                              
                           )
                        )
                     ),
                     sinonsi(
                        condition((egal(dansCst , true))),
                        alors(
                           #(
                              
                              
                              
                              ============================
                              Si on est dans une constante
                              ============================
                           ),
                           choix(
                              si(
                                 condition((egal(c , '\''))),
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(i , l01-1))),
                                          alors(
                                             affecte(temp , obj((status , false) , (id , i) , (value , T) , (message , '-1 la racine ne peut pas contenir des constantes'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    ),
                                    affecte(c1 , tableauEntree[i+1][0]),
                                    choix(
                                       si(
                                          condition(
                                             (egal(c1 , ',')),
                                             ou(egal(c1 , '\t')),
                                             ou(egal(c1 , '\n')),
                                             ou(egal(c1 , '\r')),
                                             ou(egal(c1 , '/')),
                                             ou(egal(c1 , ' ')),
                                             ou(egal(c1 , ')'))
                                          ),
                                          alors(affecte(dernier , i-1))
                                       ),
                                       sinon(
                                          alors(
                                             affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'apres une constante, il doit y avoir un caractère d\'echappement'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    ),
                                    affecte(dansCst , false),
                                    affecte(indice , indice+1),
                                    affecte(constanteQuotee , true),
                                    choix(
                                       si(
                                          condition((egal(niveau , 0))),
                                          alors(
                                             affecte(temp , obj((status , false) , (id , i) , (value , T) , (message , '-1 la racine ne peut pas contenir des constantes'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    ),
                                    appelf(
                                       n(push),
                                       element(T),
                                       p(
                                          appelf(
                                             n(Array),
                                             p(indice),
                                             p(texte),
                                             p('c'),
                                             p(niveau),
                                             p(constanteQuotee),
                                             p(premier),
                                             p(dernier),
                                             p(0),
                                             p(0),
                                             p(0),
                                             p(0),
                                             p(posOuvPar),
                                             p(posFerPar),
                                             p('')
                                          )
                                       )
                                    ),
                                    affecte(texte , ''),
                                    affecte(constanteQuotee , false)
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , '\\'))),
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(i , l01-1))),
                                          alors(
                                             affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'un antislash ne doit pas terminer une fonction'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    ),
                                    #(),
                                    affecte(c1 , tableauEntree[i+1][0]),
                                    choix(
                                       si(
                                          condition((egal(c1 , '\\')) , ou(egal(c1 , '\'')) , ou(egal(c1 , 'n')) , ou(egal(c1 , 't')) , ou(egal(c1 , 'r'))),
                                          alors(
                                             choix(
                                                si(
                                                   condition((egal(texte , ''))),
                                                   alors(affecte(premier , i))
                                                )
                                             ),
                                             affecte(texte , appelf(n(concat) , p(texte) , p('\\') , p(c1))),
                                             affecte(i , i+1)
                                          )
                                       ),
                                       sinon(
                                          alors(
                                             affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'un antislash doit être suivi par un autre antislash ou un apostrophe ou n,t,r'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    )
                                 )
                              ),
                              sinon(
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(texte , ''))),
                                          alors(affecte(premier , i))
                                       )
                                    ),
                                    affecte(texte , appelf(n(concat) , p(texte) , p(c)))
                                 )
                              )
                           ),
                           #(
                              ===================================
                              Fin de Si on est dans une constante
                              ===================================
                              
                              
                              
                           )
                        )
                     ),
                     sinon(
                        alors(
                           #(
                              
                              
                              
                              ==================================================
                              on n'est pas dans un commentaire ou une constante,  
                              donc c'est un nouveau type qu'il faut détecter
                              ==================================================
                           ),
                           choix(
                              si(
                                 condition((egal(c , '('))),
                                 alors(
                                    #(
                                       ====================
                                       Parenthèse ouvrante
                                       ====================
                                       
                                       
                                    ),
                                    affecte(posOuvPar , i),
                                    affecte(indice , indice+1),
                                    choix(
                                       si(
                                          condition((egal(texte , DEBUTCOMMENTAIRE))),
                                          alors(affecte(dsComment , vrai) , affecte(niveauDebutCommentaire , niveau))
                                       )
                                    ),
                                    appelf(
                                       n(push),
                                       element(T),
                                       p(
                                          appelf(
                                             n(Array),
                                             p(indice),
                                             p(texte),
                                             p('f'),
                                             p(niveau),
                                             p(constanteQuotee),
                                             p(premier),
                                             p(dernier),
                                             p(0),
                                             p(0),
                                             p(0),
                                             p(0),
                                             p(posOuvPar),
                                             p(posFerPar),
                                             p('')
                                          )
                                       )
                                    ),
                                    affecte(niveau , niveau+1),
                                    affecte(texte , ''),
                                    affecte(dansCst , faux),
                                    #(
                                       ==========================
                                       FIN DE Parenthèse ouvrante
                                       ==========================
                                       
                                       
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , ')'))),
                                 alors(
                                    #(
                                       
                                       
                                       ====================
                                       Parenthèse fermante
                                       ====================
                                    ),
                                    affecte(posFerPar , i),
                                    choix(
                                       si(
                                          condition((diff(texte , ''))),
                                          alors(
                                             choix(
                                                si(
                                                   condition((egal(niveau , 0))),
                                                   alors(
                                                      affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'une fermeture de parenthése ne doit pas être au niveau 0'))),
                                                      revenir(appelf(n(logerreur) , p(temp)))
                                                   )
                                                )
                                             ),
                                             affecte(indice , indice+1),
                                             appelf(
                                                n(push),
                                                element(T),
                                                p(
                                                   appelf(
                                                      n(Array),
                                                      p(indice),
                                                      p(texte),
                                                      p('c'),
                                                      p(niveau),
                                                      p(constanteQuotee),
                                                      p(premier),
                                                      p(dernier),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p('')
                                                   )
                                                )
                                             ),
                                             affecte(texte , '')
                                          )
                                       )
                                    ),
                                    affecte(niveau , niveau-1),
                                    #(
                                       
                                       maj de la position de fermeture de la parenthèse
                                       
                                    ),
                                    boucle(
                                       initialisation(affecte(j , indice)),
                                       condition(supeg(j , 0)),
                                       increment(affecte(j , j-1)),
                                       faire(
                                          choix(
                                             si(
                                                condition((egal(T[j][3] , niveau)) , et(egal(T[j][2] , 'f'))),
                                                alors(affecte(T[j][12] , posFerPar) , break())
                                             )
                                          )
                                       )
                                    ),
                                    affecte(posFerPar , 0),
                                    affecte(dansCst , false),
                                    #(
                                       ==========================
                                       FIN de Parenthèse fermante
                                       ==========================
                                       
                                       
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , '\\'))),
                                 alors(
                                    #(
                                       
                                       
                                       ===========
                                       anti slash 
                                       ===========
                                    ),
                                    choix(
                                       si(
                                          condition(non(dansCst)),
                                          alors(
                                             affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'un antislash doit être dans une constante'))),
                                             revenir(appelf(n(logerreur) , p(temp)))
                                          )
                                       )
                                    ),
                                    #(
                                       ===================
                                       Fin d'un anti slash
                                       ===================
                                       
                                       
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , '\''))),
                                 alors(
                                    #(
                                       
                                       
                                       //===========
                                       // apostrophe
                                       //===========
                                    ),
                                    affecte(premier , i),
                                    choix(
                                       si(
                                          condition((egal(dansCst , vrai))),
                                          alors(affecte(dansCst , faux))
                                       ),
                                       sinon(alors(affecte(dansCst , vrai)))
                                    ),
                                    #(
                                       //===============
                                       // FIN apostrophe
                                       //===============
                                       
                                       
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , ','))),
                                 alors(
                                    #(
                                       
                                       
                                       //========================
                                       // virgule donc séparateur
                                       //========================
                                    ),
                                    choix(
                                       si(
                                          condition((diff(texte , ''))),
                                          alors(
                                             affecte(indice , indice+1),
                                             choix(
                                                si(
                                                   condition((egal(niveau , 0))),
                                                   alors(
                                                      affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'la racine ne peut pas contenir des constantes'))),
                                                      revenir(appelf(n(logerreur) , p(temp)))
                                                   )
                                                )
                                             ),
                                             appelf(
                                                n(push),
                                                element(T),
                                                p(
                                                   appelf(
                                                      n(Array),
                                                      p(indice),
                                                      p(texte),
                                                      p('c'),
                                                      p(niveau),
                                                      p(constanteQuotee),
                                                      p(premier),
                                                      p(dernier),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p('')
                                                   )
                                                )
                                             )
                                          )
                                       ),
                                       sinon(
                                          alors(
                                             choix(
                                                si(
                                                   condition((egal(T[indice][2] , 'f'))),
                                                   alors(
                                                      #(ne rien faire)
                                                   )
                                                ),
                                                sinon(
                                                   alors(
                                                      choix(
                                                         si(
                                                            condition((supeg(T[indice][3] , niveau))),
                                                            alors(
                                                               #(ne rien faire)
                                                            )
                                                         ),
                                                         sinon(
                                                            alors(
                                                               affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'une virgule ne doit pas être précédée d\'un vide'))),
                                                               revenir(appelf(n(logerreur) , p(temp)))
                                                            )
                                                         )
                                                      )
                                                   )
                                                )
                                             )
                                          )
                                       )
                                    ),
                                    affecte(texte , ''),
                                    affecte(dansCst , faux),
                                    #(
                                       //============================
                                       // FIN virgule donc séparateur
                                       //============================
                                       
                                       
                                    )
                                 )
                              ),
                              sinonsi(
                                 condition((egal(c , ' ')) , ou(egal(c , '\t')) , ou(egal(c , '\r')) , ou(egal(c , '\n'))),
                                 alors(
                                    #(
                                       
                                       
                                       =============================
                                       caractères séparateurs de mot
                                       =============================
                                    ),
                                    choix(
                                       si(
                                          condition((diff(texte , ''))),
                                          alors(
                                             affecte(indice , indice+1),
                                             choix(
                                                si(
                                                   condition((egal(niveau , 0))),
                                                   alors(
                                                      affecte(temp , obj((status , false) , (value , T) , (id , i) , (message , 'la racine ne peut pas contenir des constantes'))),
                                                      revenir(appelf(n(logerreur) , p(temp)))
                                                   )
                                                )
                                             ),
                                             appelf(
                                                n(push),
                                                element(T),
                                                p(
                                                   appelf(
                                                      n(Array),
                                                      p(indice),
                                                      p(texte),
                                                      p('c'),
                                                      p(niveau),
                                                      p(constanteQuotee),
                                                      p(premier),
                                                      p(dernier),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p(0),
                                                      p('')
                                                   )
                                                )
                                             ),
                                             affecte(texte , ''),
                                             affecte(dansCst , faux)
                                          )
                                       )
                                    ),
                                    #(
                                       ====================================
                                       FIN de caractères séparateurs de mot
                                       ====================================
                                       
                                       
                                    )
                                 )
                              ),
                              sinon(
                                 #(
                                    
                                    
                                    ==========================
                                    tous les autres caractères
                                    ==========================
                                 ),
                                 alors(
                                    choix(
                                       si(
                                          condition((egal(texte , ''))),
                                          alors(affecte(premier , i))
                                       )
                                    ),
                                    affecte(dernier , i),
                                    affecte(texte , appelf(n(concat) , p(texte) , p(c)))
                                 )
                              )
                           )
                        )
                     )
                  )
               )
            ),
            #(
               ========================================
               on est en dehors de la boucle principale
               ========================================
            ),
            choix(
               si(
                  condition((diff(niveau , 0)) , et(exitOnLevelError)),
                  alors(
                     affecte(temp , obj((status , false) , (value , T) , (message , 'des parenthèses ne correspondent pas'))),
                     revenir(appelf(n(logerreur) , p(temp)))
                  )
               )
            ),
            #(),
            choix(
               si(
                  condition((diff(texte , ''))),
                  alors(
                     affecte(indice , indice+1),
                     choix(
                        si(
                           condition((egal(niveau , 0))),
                           alors(
                              affecte(temp , obj((status , false) , (value , T) , (message , 'la racine ne peut pas contenir des constantes'))),
                              revenir(appelf(n(logerreur) , p(temp)))
                           )
                        )
                     ),
                     #(),
                     appelf(
                        element(T),
                        n(push),
                        p(
                           appelf(
                              n(Array),
                              p(indice),
                              p(texte),
                              p('c'),
                              p(niveau),
                              p(constanteQuotee),
                              p(premier),
                              p(dernier),
                              p(0),
                              p(0),
                              p(0),
                              p(0),
                              p(0),
                              p(0),
                              p('')
                           )
                        )
                     )
                  )
               )
            ),
            #(
               
               ==============================================================
               // mise à jour de l'id du parent[7] et du nombre d'éléments[8]
               ============================================================== 
            ),
            affecte(l01 , T.length),
            boucle(
               initialisation(affecte(i , l01-1)),
               condition(sup(i , 0)),
               increment(affecte(i , i-1)),
               faire(
                  affecte(niveau , T[i][3]),
                  boucle(
                     initialisation(affecte(j , i)),
                     condition(supeg(j , 0)),
                     increment(affecte(j , j-1)),
                     faire(
                        choix(
                           si(
                              condition((egal(T[j][3] , niveau-1))),
                              alors(affecte(T[i][7] , j) , affecte(T[j][8] , T[j][8]+1) , break())
                           )
                        )
                     )
                  )
               )
            ),
            #(
               
               ============================== 
               numérotation des enfants
               numenfant = k
               ==============================
            ),
            affecte(k , 0),
            boucle(
               initialisation(affecte(i , 0)),
               condition(inf(i , l01)),
               increment(affecte(i , i+1)),
               faire(
                  affecte(k , 0),
                  boucle(
                     initialisation(affecte(j , i+1)),
                     condition(inf(j , l01)),
                     increment(affecte(j , j+1)),
                     faire(
                        choix(
                           si(
                              condition((egal(T[j][7] , T[i][0]))),
                              alors(affecte(k , k+1) , affecte(T[j][9] , k))
                           )
                        )
                     )
                  )
               )
            ),
            #(
               =======================================
               profondeur des fonctions
               k=remonterAuNiveau
               l=idParent
               =======================================
            ),
            boucle(
               initialisation(affecte(i , l01-1)),
               condition(sup(i , 0)),
               increment(affecte(i , i-1)),
               faire(
                  choix(
                     si(
                        condition((egal(T[i][2] , 'c'))),
                        alors(affecte(T[i][10] , 0))
                     )
                  ),
                  choix(
                     si(
                        condition((sup(T[i][7] , 0))),
                        alors(
                           affecte(k , T[i][3]),
                           affecte(l , T[i][7]),
                           boucle(
                              initialisation(affecte(j , 1)),
                              condition(infeg(j , k)),
                              increment(affecte(j , j+1)),
                              faire(
                                 choix(
                                    si(
                                       condition((inf(T[l][10] , j))),
                                       alors(affecte(T[l][10] , j))
                                    )
                                 ),
                                 affecte(l , T[l][7])
                              )
                           )
                        )
                     )
                  )
               )
            ),
            affecte(temp , obj((status , true) , (value , T))),
            revenir(temp)
         )
      )
   )
)