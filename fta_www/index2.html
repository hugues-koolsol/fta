<!DOCTYPE html>
<html lang="fr">
<head>
 <meta charset="utf-8" />
 <title>html home</title>
 <meta name="viewport" content="width=device-width, initial-scale=1" />
 <link rel="stylesheet" href="index.css" />
</head>
<body>
  <nav>
    <a href="index.html">html home</a>
    <a href="index.php">php home</a>
    <a href="todo.html">todo</a>
    <a href="funcToArray6.html">funcToArray6</a>
    <a href="aa_login.php">login</a>
  </nav>
  <h1>HTML HOME  &#128169;</h1>
  <ul class="menu2">
    <li><a href="index.html">html home</a></li>
    <li><a href="index.php">php home</a></li>
    <li><a href="index_php.html">index_php.html</a></li>
    <li><a href="index_js.html">index_js.html</a></li>
    <li><a href="indexfu.html">indexfu.html</a></li>
    <li><a href="index_source.html">index_source.html</a></li>
  </ul>
  
<textarea class="txtar1" id="txtar1" rows="5">a(
  // =========================
  b( 
 //
c , d( e(  ) ) ),
)</textarea>
  
<!--  
<textarea class="txtar1" id="txtar1" rows="5">a(
  // aa
  b(
    'c\'\\d') , e
)</textarea>  
-->

<!--
<textarea class="txtar1" id="txtar1" rows="5">a(
  // =========================
  b( c , d( e( f(g) ) ) ),
)</textarea>
-->
  
<!--  
<textarea class="txtar1" id="txtar1" rows="5">a(
  // 
  b(c,''),
  d(e(f))
)</textarea>
-->

<!--
<textarea class="txtar1" id="txtar1" rows="4">a(
  'a,b',
  // test
  c
)</textarea>
-->

<!-- 
  <textarea class="txtar1" id="txtar1" rows="4">// d√©but
/*
aaaa
*/
// debut
a(
  // test üëç   
  b(
    // aa
    xx(
      // dedans
/*
   commentaire bloc
/*
  commentaire bloc
*/
 commentaire bloc
*/
    ) , 
    // bb
    5
    //cc
  ) , 
  // comment 1
  c(
    ' dd  ',
    // bla
    // blu
    ee,
    2
    // @
  )
  // comment 2
),
// I√±t√´rn√¢ti√¥n√†√†ÃÄliz√¶ti√∏n ‚òÉ üí© ‚ù§ üòÅ üëç
f(g)
//üëçüòÅüí•üí™üëé‚òÄüåûüü•üü©</textarea>
-->

<!--

  <textarea class="txtar1" id="txtar1" rows="4">src_javascript(
  ( file_name , core1 ),
  ( file_extension , js ),
  ( file_path , . ),
  ( strict() ),
  source(
    declare( globale_LangueCourante , 'fr' ),
    fonction(
      definition(
        nom(fta1),
        argument(o),
        argument(exitOnLevelError)
      ),
      contenu(
        // =========================
        // les chaines de caract√®res
        // =========================
        declare( t , '' ) , declare( texte , '' ) , declare( commentaire , '' ),
        declare( c , '' ) , declare( c1 , '' ) , declare( c2 , '' ) , declare( cst , '' ),
        declare( commentaireAvant , '' ) , declare( commentaireApres , '' ),
        declare( commentaireDedans , '' ),
        declare( typCommApNett , '' ) , declare( typCommDeNett , '' ),
        declare( typCommAvNett , '' ),
        declare( CommApNett , '' ) , declare( CommDeNett , '' ),
        declare( CommAvNett , '' ),
        // =========================
        // les entiers
        // =========================
        declare( i , 0 ) , declare( j , 0 ) , declare( k , 0 ) , declare( l , 0 ),
        declare( indice , 0 ) , declare( niveau , 0 ),
        declare( niveauBloc , 0 ),
        declare( premier , 0 ),
        declare( dernier , 0 ),
        declare( debutIgnore , 0 ),
        declare( finIgnore , 0 ),
        declare( numeroLigne , 0 ),
        declare( parentId , 0 ),
        declare( nombreEnfants , 0 ),
        declare( numEnfant , 0 ),
        declare( profondeur , 0 ),
        declare( posOuvPar , 0 ),
        declare( posFerPar , 0 ),
        declare( numLigneFermeturePar , 0 ),
        // =========================
        // les bool√©ens
        // =========================
        declare( dansCst , false ) , declare( dansTexte , false ),
        declare( dansCommentaireLigne , false ) , declare( dansCommentaireBloc , false ),
        declare( constanteQuotee , false ) , declare( faireCommentaire , true ),
        declare( levelError , false ) , declare( dansIgnore , false ),
        // =========================
        // les autres
        // =========================
        declare( T , new( appelf( n(Array) ) ) ),
        // =======================================================================
        // initialisation du tableau contenant le source structur√© en arborescence
        // =======================================================================
        appelf(
          n(T.push),
          p(
            appelf(
              n(array),
              p(0),
              p(texte),
              p('INIT'),
              p(-1),
              p(constanteQuotee),
              p(premier) , p(dernier),
              p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
              p(0) , p(0) , p(0) , p(0),
              p(numLigneFermeturePar),
              p(profondeur),
              p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
              p(CommApNett) , p(CommDeNett) , p(CommAvNett),
              p(posOuvPar) , p(posFerPar)
            )
          )
        ),
        declare( l01 , o.length ),

        // ====================================================================
        // ====================================================================
        // boucle principale sur tous les caract√®res du texte pass√© en argument
        // on commence par analyser les cas ou on est dans des chaines, puis on
        // analyse les caract√®res
        // ====================================================================
        // ====================================================================

        boucle(
          initialisation( affecte( i , 0 ) ),
          condition( inf( i , l01 ) ),
          increment( affecte( i , i+1 ) ),
          faire(
            affecte( c , appelf( n(o.substr) , p(i) , p(1) ) ),
            choix(
              si(
                // ==================
                // dans une constante
                // ==================
                condition( ( egal( dansCst , true ) ) ),
                alors(
                  choix(
                    si(
                      condition( ( egal( c , '\'' ) ) ),
                      alors(
                        choix(
                          si(
                            condition( ( diff( i , l01-1 ) ) ),
                            alors(
                              affecte( c1 , appelf( n(o.substr) , p(i+1) , p(1) ) ),
                              choix(
                                si(
                                  condition(
                                    ( egal( c1 , ',' ) ),
                                    ou( egal( c1 , '\t' ) ),
                                    ou( egal( c1 , '\n' ) ),
                                    ou( egal( c1 , '\r' ) ),
                                    ou( egal( c1 , '/' ) ),
                                    ou( egal( c1 , ' ' ) ),
                                    ou( egal( c1 , ')' ) )
                                  ),
                                  alors(
                                    affecte( dernier , i-1 )
                                  )
                                ),
                                sinon(
                                  alors(
                                    affecte(
                                      temp,
                                      obj(
                                        ( status , false ),
                                        ( value , T ),
                                        ( message , 'apres une constante, il doit y avoir un caract√®re d\'echappement' )
                                      )
                                    ),
                                    revenir(
                                      appelf( n(logerreur) , p(temp) )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        ),
                        affecte( dansCst , false ),
                        affecte( indice , indice+1 ),
                        affecte( constanteQuotee , true ),
                        choix(
                          si(
                            condition(
                              ( egal( dansIgnore , true ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( egal( texte , '' ) )
                                  ),
                                  alors(
                                    appelf(
                                      r(commentaireAvant),
                                      n(o.substr),
                                      p(debutIgnore),
                                      p(premier-debutIgnore)
                                    )
                                  )
                                ),
                                sinon(
                                  alors(
                                    appelf(
                                      r(commentaireAvant),
                                      n(o.substr),
                                      p(debutIgnore),
                                      p(premier-debutIgnore-1)
                                    )
                                  )
                                )
                              ),
                              affecte( dansIgnore , false )
                            )
                          )
                        ),
                        appelf( r(numeroLigne) , n(calculNumLigne) , p(o) , p(premier) ),
                        appelf(
                          n(T.push),
                          p(
                            appelf(
                              n(array),
                              p(indice),
                              p(texte),
                              p('c'),
                              p(niveau),
                              p(constanteQuotee),
                              p(premier) , p(dernier),
                              p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
                              p(parentId) , p(nombreEnfants) , p(numEnfant) , p(numeroLigne),
                              p(numLigneFermeturePar),
                              p(profondeur),
                              p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
                              p(CommApNett) , p(CommDeNett) , p(CommAvNett),
                              p(posOuvPar) , p(posFerPar)
                            )
                          )
                        ),
                        affecte( texte , '' ),
                        affecte( commentaireAvant , '' ),
                        affecte( constanteQuotee , false )
                      )
                    ),
                    sinonsi(
                      condition(
                        ( egal( c , '\\' ) )
                      ),
                      alors(
                        choix(
                          si(
                            condition( ( egal( i , l01-1 ) ) ),
                            alors(
                              affecte(
                                temp,
                                obj(
                                  ( status , false ),
                                  ( value , T ),
                                  ( message , 'un antislash ne doit pas terminer une fonction' )
                                )
                              ),
                              revenir(
                                appelf( n(logerreur) , p(temp) )
                              )
                            )
                          ),
                          sinon(
                            alors(
                              affecte( c1 , appelf( n(o.substr) , p(i+1) , p(1) ) ),
                              choix(
                                si(
                                  condition(
                                    ( egal( c1 , '\\' ) ),
                                    ou( egal( c1 , '\'' ) )
                                  ),
                                  alors(
                                    choix(
                                      si(
                                        condition(
                                          ( egal( texte , '' ) )
                                        ),
                                        alors(
                                          affecte( premier , i )
                                        )
                                      )
                                    ),
                                    affecte( texte , appelf( n(concat) , p(texte) , p(c1) ) ),
                                    affecte( i , i+1 )
                                  )
                                ),
                                sinon(
                                  alors(
                                    choix(
                                      si(
                                        condition(
                                          ( egal( c1 , 'n' ) ),
                                          ou( egal( c1 , 't' ) ),
                                          ou( egal( c1 , 'r' ) )
                                        ),
                                        alors(
                                          choix(
                                            si(
                                              condition(
                                                ( egal( texte , '' ) )
                                              ),
                                              alors(
                                                affecte( premier , i )
                                              )
                                            )
                                          ),
                                          affecte( texte , appelf( n(concat) , p('\\') , p(c1) ) ),
                                          affecte( i , i+1 )
                                        )
                                      ),
                                      sinon(
                                        alors(
                                          affecte(
                                            temp,
                                            obj(
                                              ( status , false ),
                                              ( value , T ),
                                              ( message , 'un antislash doit √™tre suivi par un autre antislash ou un apostrophe' )
                                            )
                                          ),
                                          revenir(
                                            appelf( n(logerreur) , p(temp) )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    ),
                    sinon(
                      alors(
                        choix(
                          si(
                            condition(
                              ( egal( texte , '' ) )
                            ),
                            alors(
                              affecte( premier , i )
                            )
                          )
                        ),
                        affecte( texte , appelf( n(concat) , p(texte) , p(c) ) )
                      )
                    )
                  )
                )
              ),
              sinonsi(
                // ========================================
                // dans un commentaire de type ligne ( // )
                // ========================================
                condition( ( egal( dansCommentaireLigne , true ) ) ),
                alors(
                  boucle(
                    initialisation( affecte( j , i ) ),
                    condition( inf( j , l01 ) ),
                    increment( affecte( j , j+1 ) ),
                    faire(
                      affecte( c1 , appelf( n(o.substr) , p(j) , p(1) ) ),
                      choix(
                        si(
                          condition(
                            ( egal( c1 , '\n' ) ),
                            ou( egal( c1 , '\r' ) )
                          ),
                          alors(
                            affecte( dansCommentaireLigne , false ),
                            affecte( i , j ),
                            break()
                          )
                        )
                      )
                    )
                  )
                )
              ),
              sinonsi(
                // =======================================
                // dans un commentaire de type bloc ( /* )
                // =======================================
                condition( ( egal( dansCommentaireBloc , true ) ) ),
                alors(
                  boucle(
                    initialisation( affecte( j , i ) ),
                    condition( inf( j , l01-1 ) ),
                    increment( affecte( j , j+1 ) ),
                    faire(
                      affecte( c1 , appelf( n(o.substr) , p(j) , p(1) ) ),
                      affecte( c2 , appelf( n(o.substr) , p(j+1) , p(1) ) ),
                      choix(
                        si(
                          condition(
                            ( egal( c1 , '/' ) ),
                            et( egal( c1 , '*' ) ),
                            et(
                              ( egal( i , 0 ) ),
                              ou(
                                egal( appelf( n(o.substr) , p(j-1) , p(1) ) , '\r' )
                              ),
                              ou(
                                egal( appelf( n(o.substr) , p(j-1) , p(1) ) , '\n' )
                              )
                            )
                          ),
                          alors(
                            affecte( niveauBloc , niveauBloc+1 )
                          )
                        ),
                        sinonsi(
                          condition(
                            ( egal( c1 , '*' ) ),
                            et( egal( c1 , '/' ) ),
                            et(
                              (
                                egal( appelf( n(o.substr) , p(j-1) , p(1) ) , '\r' )
                              ),
                              ou(
                                egal( appelf( n(o.substr) , p(j-1) , p(1) ) , '\n' )
                              )
                            )
                          ),
                          alors(
                            affecte( niveauBloc , niveauBloc-1 )
                          )
                        )
                      ),
                      choix(
                        si(
                          condition(
                            ( egal( niveauBloc , 0 ) )
                          ),
                          alors(
                            affecte( dansCommentaireBloc , false ),
                            affecte( i , j+1 ),
                            break()
                          )
                        )
                      )
                    )
                  )
                )
              ),
              sinon(
                alors(
                  // ==================================================
                  // ==================================================
                  // on n'est pas dans un commentaire ou une constante,  
                  // donc c'est un nouveau type qu'il faut d√©tecter
                  // ==================================================
                  choix(
                    si(
                      //====================
                      // Parenth√®se ouvrante
                      //====================
                      condition(
                        ( egal( c , '(' ) )
                      ),
                      alors(
                        affecte( posOuvPar , i ),
                        choix(
                          si(
                            condition(
                              ( egal( dansIgnore , true ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( egal( texte , '' ) )
                                  ),
                                  alors(
                                    affecte(
                                      commentaireAvant,
                                      appelf(
                                        n(o.substr),
                                        p(debutIgnore),
                                        p(i-debutIgnore)
                                      )
                                    )
                                  )
                                ),
                                sinon(
                                  alors(
                                    affecte(
                                      commentaireAvant,
                                      appelf(
                                        n(o.substr),
                                        p(debutIgnore),
                                        p(premier-debutIgnore)
                                      )
                                    )
                                  )
                                )
                              ),
                              affecte( dansIgnore , faux )
                            )
                          )
                        ),
                        affecte( indice , indice+1 ),
                        choix(
                          si(
                            condition(
                              non(
                                egal( texte , '' )
                              )
                            ),
                            alors(
                              affecte(
                                numeroLigne,
                                appelf(
                                  n(calculNumLigne),
                                  p(o),
                                  p(i)
                                )
                              )
                            )
                          ),
                          sinon(
                            alors(
                              affecte(
                                numeroLigne,
                                appelf(
                                  n(calculNumLigne),
                                  p(o),
                                  p(premier)
                                )
                              )
                            )
                          )
                        ),
                        appelf(
                          n(T.push),
                          p(
                            appelf(
                              n(array),
                              p(indice),
                              p(texte),
                              p('c'),
                              p(niveau),
                              p(constanteQuotee),
                              p(premier) , p(dernier),
                              p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
                              p(parentId) , p(nombreEnfants) , p(numEnfant) , p(numeroLigne),
                              p(numLigneFermeturePar),
                              p(profondeur),
                              p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
                              p(CommApNett) , p(CommDeNett) , p(CommAvNett),
                              p(posOuvPar) , p(posFerPar)
                            )
                          )
                        ),
                        boucle(
                          initialisation( affecte( i , T.length-1 ) ),
                          condition( sup( j , 0 ) ),
                          increment( affecte( j , j-1 ) ),
                          faire(
                            affecte( l , T[j][3] ),
                            boucle(
                              initialisation( affecte( k , j ) ),
                              condition( supeg( k , 0 ) ),
                              increment( affecte( k , k-1 ) ),
                              faire(
                                affecte( T[j][10] , k ),
                                break()
                              )
                            )
                          )
                        ),
                        affecte( niveau , niveau+1 ),
                        affecte( texte , '' ),
                        affecte( commentaireAvant , '' ),
                        affecte( commentaireApres , '' ),
                        affecte( dansCst , faux ),
                        affecte( dansTexte , faux ),
                        affecte( dansCommentaireLigne , faux ),
                        affecte( dansCommentaireBloc , faux )
                      )
                    ),
                    sinonsi(
                      //====================
                      // Parenth√®se fermante
                      //====================
                      condition(
                        ( egal( c , ')' ) )
                      ),
                      alors(
                        affecte( posFerPar , i ),
                        affecte( faireCommentaire , vrai ),
                        choix(
                          si(
                            condition(
                              ( diff( texte , '' ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    // une constante est le dernier param√®tre d'une fonction 
                                    // et ne comporte pa de virgule, ex : a((b c))
                                    ( egal( dansIgnore , true ) )
                                  ),
                                  alors(
                                    appelf(
                                      n(o.substr),
                                      r(commentaireAvant),
                                      p(debutIgnore),
                                      p(premier-debutIgnore)
                                    )
                                  )
                                )
                              ),
                              affecte( indice , indice+1 ),
                              appelf(
                                n(calculNumLigne),
                                r(numeroLigne),
                                p(o),
                                p(premier)
                              ),
                              appelf(
                                n(T.push),
                                p(
                                  appelf(
                                    n(array),
                                    p(indice),
                                    p(texte),
                                    p('c'),
                                    p(niveau),
                                    p(constanteQuotee),
                                    p(premier) , p(dernier),
                                    p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
                                    p(parentId) , p(nombreEnfants) , p(numEnfant) , p(numeroLigne),
                                    p(numLigneFermeturePar),
                                    p(profondeur),
                                    p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
                                    p(CommApNett) , p(CommDeNett) , p(CommAvNett),
                                    p(posOuvPar) , p(posFerPar)
                                  )
                                )
                              ),
                              affecte( texte , '' ),
                              affecte( commentaireAvant , '' ),
                              affecte( faireCommentaire , faux )
                            )
                          )
                        ),
                        choix(
                          si(
                            condition(
                              ( egal( dansIgnore , vrai ) ),
                              et( egal( faireCommentaire , vrai ) )
                            ),
                            alors(
                              affecte( a , 1 ),
                              choix(
                                si(
                                  condition(
                                    ( sup( niveau , T[indice][3] ) )
                                  ),
                                  alors(
                                    appelf(
                                      n(o.substr),
                                      r(commentaireDedans),
                                      p(debutIgnore),
                                      p(i-debutIgnore)
                                    ),
                                    affecte( T[indice][9] , commentaireDedans ),
                                    affecte( commentaireDedans , '' ),
                                    affecte( dansIgnore , false )
                                  )
                                ),
                                sinon(
                                  alors(
                                    boucle(
                                      initialisation( affecte( k , indice ) ),
                                      condition( sup( k , 0 ) ),
                                      increment( affecte( k , k-1 ) ),
                                      faire(
                                        choix(
                                          si(
                                            condition(
                                              ( egal( T[k][3] , niveau ) )
                                            ),
                                            alors(
                                              appelf(
                                                n(o.substr),
                                                r(commentaireApres),
                                                p(debutIgnore),
                                                p(i-debutIgnore)
                                              ),
                                              affecte( T[k][8] , commentaireApres ),
                                              affecte( commentaireApres , '' ),
                                              affecte( dansIgnore , false ),
                                              break()
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        ),
                        choix(
                          si(
                            condition(
                              // si le dernier argument d'une fonction est une constante, 
                              // il faut remonter pour chercher le commentaire apres

                              ( egal( T[indice][2] , 'c' ) ),
                              et( egal( niveau , T[indice][3] ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( egal( T[indice][4] , vrai ) )
                                  ),
                                  alors(
                                    affecte( k , T[indice][6]+2 )
                                  )
                                ),
                                sinon(
                                  alors( affecte( k , T[indice][6]+1 ) )
                                )
                              ),
                              choix(
                                si(
                                  condition(
                                    ( inf( k , i ) )
                                  ),
                                  alors(
                                    appelf(
                                      n(o.substr),
                                      r(commentaireApres),
                                      p(k),
                                      p(i-k)
                                    )
                                  )
                                )
                              )
                            )
                          )
                        ),
                        affecte( a , 1 ),
                        appelf(
                          n(calculNumLigne),
                          r(numeroLigne),
                          p(o),
                          p(i)
                        ),
                        // recherche du numLiParent
                        boucle(
                          initialisation( affecte( j , indice ) ),
                          condition( sup( j , 0 ) ),
                          increment( affecte( j , j-1 ) ),
                          faire(
                            choix(
                              si(
                                condition(
                                  ( egal( T[j][3] , niveau-1 ) )
                                ),
                                alors(
                                  affecte( T[j][14] , numeroLigne ),
                                  break()
                                )
                              )
                            )
                          )
                        ),
                        affecte( niveau , niveau-1 ),
                        //
                        // maj de la position de fermeture de la parenth√®se
                        //
                        boucle(
                          initialisation( affecte( j , indice ) ),
                          condition( supeg( j , 0 ) ),
                          increment( affecte( j , j-1 ) ),
                          faire(
                            affecte( a , 1 ),
                            choix(
                              si(
                                condition(
                                  ( egal( T[j][3] , niveau ) ),
                                  et( egal( T[j][2] , '' ) )
                                ),
                                alors(
                                  affecte( T[j][23] , posFerPar ),
                                  break()
                                )
                              )
                            )
                          )
                        ),
                        affecte( posFerPar , 0 ),
                        affecte( dansCst , false ),
                        affecte( dansTexte , false ),
                        affecte( dansCommentaireLigne , false ),
                        affecte( dansCommentaireBloc , false )
                      )
                    ),
                    sinonsi(
                      //==========
                      // antislash
                      // TODO a revoir
                      //==========
                      condition( ( egal( c , '\\' ) ) ),
                      alors(
                        affecte(
                          temp,
                          obj(
                            ( status , false ),
                            ( value , T ),
                            ( message , 'un antislash doit √™tre dans une constante' )
                          )
                        ),
                        revenir(
                          appelf( n(logerreur) , p(temp) )
                        )
                      )
                    ),
                    sinonsi(
                      //===========
                      // apostrophe
                      //===========
                      condition( ( egal( c , '\'' ) ) ),
                      alors(
                        affecte( premier , i ),
                        choix(
                          si(
                            condition( ( egal( dansCst , vrai ) ) ),
                            alors( affecte( dansCst , faux ) )
                          ),
                          sinon( alors( affecte( dansCst , vrai ) ) )
                        )
                      )
                    ),
                    sinonsi(
                      condition( ( egal( c , '/' ) ) ),
                      alors(
                        //================================
                        // slash donc d√©but de commentaire
                        //================================
                        choix(
                          si(
                            condition(
                              ( egal( i , l01-1 ) )
                            ),
                            alors(
                              affecte(
                                temp,
                                obj(
                                  ( status , false ),
                                  ( value , T ),
                                  ( message , 'un slash √† la fin d\'une fonction n\'est pas autoris√©' )
                                )
                              ),
                              revenir(
                                appelf( n(logerreur) , p(temp) )
                              )
                            )
                          )
                        ),
                        affecte( c1 , appelf( n(o.substr) , p(i+1) , p(1) ) ),
                        choix(
                          si(
                            condition(
                              ( egal( c1 , '/' ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( diff( texte , '' ) )
                                  ),
                                  alors(
                                    affecte( indice , indice+1 ),
                                    choix(
                                      si(
                                        condition(
                                          ( egal( dansIgnore , true ) )
                                        ),
                                        alors(
                                          appelf(
                                            r(commentaireAvant),
                                            n(o.substr),
                                            p(debutIgnore),
                                            p(premier-debutIgnore)
                                          ),
                                          affecte( debutIgnore , i )
                                        )
                                      )
                                    ),
                                    appelf(
                                      r(numeroLigne),
                                      n(calculNumLigne),
                                      p(o),
                                      p(premier)
                                    ),
                                    appelf(
                                      n(T.push),
                                      p(
                                        appelf(
                                          n(array),
                                          p(indice),
                                          p(texte),
                                          p('c'),
                                          p(niveau),
                                          p(constanteQuotee),
                                          p(premier) , p(dernier),
                                          p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
                                          p(parentId) , p(nombreEnfants) , p(numEnfant) , p(numeroLigne),
                                          p(numLigneFermeturePar),
                                          p(profondeur),
                                          p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
                                          p(CommApNett) , p(CommDeNett) , p(CommAvNett),
                                          p(posOuvPar) , p(posFerPar)
                                        )
                                      )
                                    ),
                                    affecte( texte , '' ),
                                    affecte( commentaireAvant , '' ),
                                    affecte( commentaireApres , '' ),
                                    affecte( dansCst , faux ),
                                    affecte( dansTexte , faux ),
                                    affecte( dansCommentaireLigne , faux ),
                                    affecte( dansCommentaireBloc , faux )
                                  )
                                )
                              ),
                              affecte( dansCommentaireLigne , vrai ),
                              choix(
                                si(
                                  condition(
                                    ( egal( dansIgnore , faux ) )
                                  ),
                                  alors(
                                    affecte( debutIgnore , i )
                                  )
                                )
                              ),
                              affecte( dansIgnore , vrai )
                            )
                          ),
                          sinonsi(
                            condition( ( egal( '*' , c1 ) ) ),
                            alors(
                              affecte( c1 , appelf( n(o.substr) , p(i-1) , p(1) ) ),
                              choix(
                                si(
                                  condition(
                                    ( egal( i , 0 ) ),
                                    ou( egal( '\r' , c1 ) ),
                                    ou( egal( '\n' , c1 ) )
                                  ),
                                  alors(
                                    choix(
                                      si(
                                        condition(
                                          ( egal( dansIgnore , faux ) )
                                        ),
                                        alors(
                                          affecte( debutIgnore , i )
                                        )
                                      )
                                    ),
                                    affecte( dansIgnore , vrai ),
                                    affecte( dansCommentaireBloc , true ),
                                    affecte( i , i+1 ),
                                    affecte( niveauBloc , 1 )
                                  )
                                ),
                                sinon(
                                  alors(
                                    affecte(
                                      temp,
                                      obj(
                                        ( status , false ),
                                        ( value , T ),
                                        ( message , 'un commentaire de bloc doit commencer en colonne 1' )
                                      )
                                    ),
                                    revenir(
                                      appelf( n(logerreur) , p(temp) )
                                    )
                                  )
                                )
                              )
                            )
                          ),
                          sinon(
                            alors(
                              affecte(
                                temp,
                                obj(
                                  ( status , false ),
                                  ( value , T ),
                                  ( message , 'un slash doit √™tre suivi d\'un caract√®re * pour commencer un commentaire' )
                                )
                              ),
                              revenir(
                                appelf( n(logerreur) , p(temp) )
                              )
                            )
                          )
                        )
                      )
                    ),
                    sinonsi(
                      condition( ( egal( c , ',' ) ) ),
                      alors(
                        //========================
                        // virgule donc s√©parateur
                        //========================
                        choix(
                          si(
                            condition(
                              ( egal( texte , '' ) )
                            ),
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( egal( dansIgnore , vrai ) )
                                  ),
                                  alors(
                                    affecte(
                                      commentaireAvant,
                                      appelf(
                                        n(o.substr),
                                        p(debutIgnore),
                                        p(premier-debutIgnore)
                                      )
                                    ),
                                    affecte( dansIgnore , false )
                                  )
                                )
                              ),
                              affecte( indice , indice+1 ),
                              affecte(
                                numeroLigne,
                                appelf(
                                  n(calculNumLigne),
                                  p(o),
                                  p(premier)
                                )
                              )
                            )
                          ),
                          sinon(
                            // todo
                            // todo
                            alors(
                              choix(
                                si(
                                  condition(
                                    ( egal( dansIgnore , vrai ) )
                                  ),
                                  alors(
                                    affecte(
                                      commentaireApres,
                                      appelf(
                                        n(o.substr),
                                        p(debutIgnore),
                                        p(i-debutIgnore)
                                      )
                                    ),
                                    choix(
                                      si(
                                        condition(
                                          ( egal( T[indice][3] , niveau ) )
                                        ),
                                        alors(
                                          affecte( T[indice][8] , commentaireApres )
                                        )
                                      ),
                                      sinon(
                                        alors(
                                          boucle(
                                            initialisation( affecte( j , indice-1 ) ),
                                            condition( sup( j , 0 ) ),
                                            increment( affecte( j , j-1 ) ),
                                            faire(
                                              choix(
                                                si(
                                                  condition(
                                                    ( egal( T[j][3] , niveau ) )
                                                  ),
                                                  alors(
                                                    affecte( T[j][8] , commentaireApres ),
                                                    break()
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    ),
                                    affecte( dansIgnore , false )
                                  )
                                )
                              )
                            )
                          )
                        ),
                        affecte( texte , '' ),
                        affecte( commentaireAvant , '' ),
                        affecte( commentaireApres , '' ),
                        affecte( dansCst , faux ),
                        affecte( dansTexte , faux ),
                        affecte( dansCommentaireLigne , faux ),
                        affecte( dansCommentaireBloc , faux )
                      )
                    ),
                    sinonsi(
                      condition(
                        ( egal( c , ' ' ) ),
                        ou( egal( c , '\t' ) ),
                        ou( egal( c , '\r' ) ),
                        ou( egal( c , '\n' ) )
                      ),
                      alors(
                        choix(
                          si(
                            condition(
                              ( egal( texte , '' ) )
                            ),
                            alors(
                              affecte( indice , indice+1 ),
                              choix(
                                si(
                                  condition(
                                    ( egal( dansIgnore , vrai ) )
                                  ),
                                  alors(
                                    affecte(
                                      commentaireAvant,
                                      appelf(
                                        n(o.substr),
                                        p(debutIgnore),
                                        p(premier-debutIgnore)
                                      )
                                    ),
                                    affecte( debutIgnore , i )
                                  )
                                )
                              ),
                              affecte(
                                numeroLigne,
                                appelf(
                                  n(calculNumLigne),
                                  p(o),
                                  p(premier)
                                )
                              ),
                              appelf(
                                n(T.push),
                                p(
                                  appelf(
                                    n(array),
                                    p(indice),
                                    p(texte),
                                    p('c'),
                                    p(niveau),
                                    p(constanteQuotee),
                                    p(premier) , p(dernier),
                                    p(commentaireAvant) , p(commentaireApres) , p(commentaireDedans),
                                    p(parentId) , p(nombreEnfants) , p(numEnfant) , p(numeroLigne),
                                    p(numLigneFermeturePar),
                                    p(profondeur),
                                    p(typCommApNett) , p(typCommDeNett) , p(typCommAvNett),
                                    p(CommApNett) , p(CommDeNett) , p(CommAvNett),
                                    p(posOuvPar) , p(posFerPar)
                                  )
                                )
                              ),
                              affecte( texte , '' ),
                              affecte( commentaireAvant , '' ),
                              affecte( commentaireApres , '' ),
                              affecte( dansCst , faux ),
                              affecte( dansTexte , faux ),
                              affecte( dansCommentaireLigne , faux ),
                              affecte( dansCommentaireBloc , faux ),
                              choix(
                                si(
                                  condition(
                                    ( egal( dansIgnore , faux ) )
                                  ),
                                  alors(
                                    affecte( debutIgnore , i )
                                  )
                                )
                              ),
                              affecte( dansIgnore , vrai )
                            )
                          ),
                          sinon(
                            alors(
                              affecte( a , 1 )
                            )
                          )
                        ),
                        affecte( apresChoix , 1 ),
                        affecte( a , 1 )
                      )
                    ),
                    sinon(
                      alors( affecte( a , 1 ) )
                    )
                  )
                )
              )
            )
          )
        )
/*        
        affecteFonction(
          r.onreadystatechange,
          contenu(
            essayer(
              faire(
                // instructions
              ),
              sierreur(
                e,
                faire(
                  // instructions
                )
              )
            )
          )
        ),
*/        
      )
    )
  )
)</textarea>
-->

  <a href="javascript:transform()">transform</a>
  <div id="message1"></div>
  <div id="resultat1"></div>
  <script type="text/javascript" src="js/core2.js"></script>
<script type="text/javascript">


function iterateCharacters(str) {
// https://stackoverflow.com/questions/63905684/how-can-a-3-byte-wide-utf-8-character-only-use-a-single-utf-16-code-unit
  var out=[];
  let te = new TextEncoder();
  let position=0;
  let position2=0;
  let arr = [...str];
  for (let i = 0; i < arr.length; i++) {
    let bytes = te.encode(arr[i]).length;
    let length = arr[i].length;
    out.push([arr[i],bytes,position,position2]);
    position+=bytes;
    position2+=(bytes==4?2:1);
  }
  return {'out':out,'position':position,'position2':position2};  
}

function transform(){
  //"√†aÃÄ"


  document.getElementById('message1').innerHTML='';
  document.getElementById('resultat1').innerHTML='';

  var a=document.getElementById('txtar1');
  
  var lines = a.value.split(/\r|\r\n|\n/);
  var count = lines.length;
  a.setAttribute('rows',count+1);
  
  
  
  var startMicro=performance.now();
  var out1=iterateCharacters(a.value);
  var endMicro=performance.now();  console.log('mise en tableau endMicro=',parseInt(((endMicro-startMicro)*1000),10)/1000+' ms');
 
//  console.log('out1.out=',out1.out);
  
  var startMicro=performance.now();
  var b=functionToArray2(out1.out);
  var endMicro=performance.now();  console.log('analyse syntaxique endMicro=',parseInt(((endMicro-startMicro)*1000),10)/1000+' ms');


//  console.log(b);
  
  document.getElementById('message1').innerHTML='';
  document.getElementById('resultat1').innerHTML='';


  if(b.status===true){
  
    var parent=document.getElementById('resultat1');
    




    var startMicro=performance.now();
    var a2fwc2=arrayToFunctWithComment2(b.value,true)
    var endMicro=performance.now();  console.log('reg√©n√©rations avec commentaires endMicro=',parseInt(((endMicro-startMicro)*1000),10)/1000+' ms');
    
    var dia2fwc2=document.createElement('pre');
    
    if(a2fwc2.status==true && a.value == a2fwc2.value ){
     dia2fwc2.innerHTML=dia2fwc2.innerHTML+'<b style="color:green;">üëç source et reg√©n√©r√©s egaux</b>';
    }else{
     dia2fwc2.innerHTML=dia2fwc2.innerHTML+'<b style="color:red;">source et reg√©n√©r√©s diff√©rents</b>';
    }
    
    if(a2fwc2.status===true){
     dia2fwc2.innerHTML=dia2fwc2.innerHTML+'<hr  />arrayToFunctWithComment2:\n'+a2fwc2.value;
    }else{
     dia2fwc2.innerHTML=dia2fwc2.innerHTML+'<hr />arrayToFunctWithComment2:'+a2fwc2.message;
    }
    
    
    document.getElementById('resultat1').appendChild(dia2fwc2);

    var d=null;
    if(a2fwc2.status===true){
     var c=functionToArray2(a2fwc2.value);
     if(c.status==true){
      d=arrayToFunctNoComment2(b.value,false)
     }
    }


    var a2fnc2=arrayToFunctNoComment2(b.value,true)
    var dia2fnc2=document.createElement('pre');
    if(a2fnc2.status===true){
     dia2fnc2.innerHTML='<hr  />arrayToFunctNoComment2:\n'+a2fnc2.value;
    }else{
     dia2fnc2.innerHTML='<hr />arrayToFunctNoComment2:'+a2fnc2.message;
    }
    document.getElementById('resultat1').appendChild(dia2fnc2);
    

    var a2fnc2f=arrayToFunctNoComment2(b.value,false)
    var dia2fnc2=document.createElement('pre');
    if(a2fnc2f.status===true){
     dia2fnc2.innerHTML='<hr  />arrayToFunctNoComment2 no return:\n'+a2fnc2f.value;
    }else{
     dia2fnc2.innerHTML='<hr />arrayToFunctNoComment2:'+a2fnc2f.message;
    }
    
    if(d!==null && d.status==true && a2fnc2f.status===true && a2fnc2f.value == d.value){
     dia2fnc2.innerHTML=dia2fnc2.innerHTML+'<br /><b style="color:green;">üëç sources compact√©s Egaux</b>';
    }else{
     dia2fnc2.innerHTML=dia2fnc2.innerHTML+'<br /><b style="color:red;">sources compact√©s diff√©rents</b>';
    }

    document.getElementById('resultat1').appendChild(dia2fnc2);
    

    


    
    
    var a2fn=arrayToFunctNormalize(b.value,false)
    var di3=document.createElement('pre');
    if(a2fn.status===true){
     
     di3.innerHTML='<hr />'+a2fn.value+''+(a2fn.value==a.value?'<br /><b style="color:green;">identiques :-)</b>':'<br /><b style="color:red;">diff√©rents :-(</b')+'';
    }else{
     di3.innerHTML='<hr />'+a2fn.message;
    }
    document.getElementById('resultat1').appendChild(di3);
    
    
    
    
    
    var t1=document.createElement('table');
    t1.setAttribute('class','tableau1');
    
    // entete de tableau de l'arbre
    var tr1=document.createElement('tr');
    for(var i=0;i<global_enteteTableau.length;i++){
      var td1=document.createElement('td');
      td1.innerHTML=global_enteteTableau[i][0];
      td1.setAttribute('title',global_enteteTableau[i][1] + '(' + i + ')');
      tr1.appendChild(td1);
    }
    t1.appendChild(tr1);
    
    // arbre
    for(var i=0;i<b.value.length;i++){
      var tr1=document.createElement('tr');
      for(var j=0;j<b.value[i].length;j++){
        var td1=document.createElement('td');
        if(j==1 || ( j>=7 && j<=9 ) ){ // pour les valeurs et les commentaires
         td1.innerHTML=String(b.value[i][j]).replace(/ /g,'‚ñë').replace(/\n/g,'\\n\n');
         td1.style.whiteSpace='pre-wrap';
         td1.style.verticalAlign='baseline';
        }else if(j==4){ // constante quot√©e
         td1.innerHTML=b.value[i][j]===true?'1':'';;
        }else{
         td1.innerHTML=String(b.value[i][j]).replace(/ /g,'‚ñë');
        }
        td1.setAttribute('title',global_enteteTableau[j][1] + '(' + j + ')');
        tr1.appendChild(td1);
      }
      t1.appendChild(tr1);
    }
    document.getElementById('resultat1').appendChild(t1);
//    parent.appendChild(t1);
    
    // d√©composition 
    var t2=document.createElement('table');
    t2.setAttribute('class','tableau2');
    var tr1=document.createElement('tr');
    var td1=document.createElement('td');
    var numeroLigne=0;
    td1.innerHTML=numeroLigne;
    tr1.appendChild(td1);
    var debut=0;
//    console.log(a.value);
    
    var outo=iterateCharacters(a.value);
    out=outo.out;
    console.log(out);
    console.log('a.value.length=',a.value.length);
    for(var i=0;i<out.length;i++){
      var td1=document.createElement('td');
      td1.innerHTML=out[i][0].replace('\n','\\n');
      td1.title='&#'+out[i][0].codePointAt(0)+'; ('+out[i][1]+')';
      tr1.appendChild(td1);
      
      
      if(out[i][0]==='\n'){
       t2.appendChild(tr1);
       
       // indice dans tableau = premi√®re ligne des chiffres
       var tr1=document.createElement('tr');
       var td1=document.createElement('td');
       td1.setAttribute('class','td2');
       td1.innerHTML='&nbsp;';
       tr1.appendChild(td1);
       
       for(var j=debut;j<i;j++){
         var td1=document.createElement('td');
         if(out[j][1]==1){
          td1.setAttribute('class','td2');
         }else if(out[j][1]==3  ){
          td1.setAttribute('class','td5');
         }else if( out[j][1]==4 ){
          td1.setAttribute('class','td4');
         }else{
          td1.setAttribute('class','td3');
         }
         td1.innerHTML=j;
         tr1.appendChild(td1);
       }
       // position du backslash n
       var td1=document.createElement('td');
       td1.setAttribute('class','td2');
       td1.innerHTML=j+'';
       tr1.appendChild(td1);
       
       t2.appendChild(tr1);
       


       
       // position dans la chaine = deuxi√®me ligne des chiffres

       var tr1=document.createElement('tr');
       var td1=document.createElement('td');
       td1.setAttribute('class','td2');
       td1.innerHTML='&nbsp;';
       tr1.appendChild(td1);
       
       for(var j=debut;j<i;j++){
         var td1=document.createElement('td');
         if(out[j][1]==1){
          td1.setAttribute('class','td2');
         }else if(out[j][1]==3  ){
          td1.setAttribute('class','td5');
         }else if( out[j][1]==4 ){
          td1.setAttribute('class','td4');
         }else{
          td1.setAttribute('class','td3');
         }
         td1.innerHTML=out[j][3]+'';
         tr1.appendChild(td1);
       }
       // position du backslash n
       var td1=document.createElement('td');
       td1.setAttribute('class','td2');
       td1.innerHTML=out[j][3]+'';
       tr1.appendChild(td1);
       
       t2.appendChild(tr1);
       
       

       // fin des lignes 
       
       
       debut=i+1;

       
       
       var tr1=document.createElement('tr');
       numeroLigne++;
       var td1=document.createElement('td');
       td1.innerHTML=numeroLigne;
       tr1.appendChild(td1);
       t2.appendChild(tr1);
       
      }
      
    }

    t2.appendChild(tr1);


    
    var tr1=document.createElement('tr');
    var td1=document.createElement('td');
    td1.setAttribute('class','td2');
    td1.innerHTML='&nbsp;';
    tr1.appendChild(td1);
    
    for(var j=debut;j<i;j++){
      var td1=document.createElement('td');
      if(out[j][1]==1){
       td1.setAttribute('class','td2');
      }else if(out[j][1]==3  ){
       td1.setAttribute('class','td5');
      }else if( out[j][1]==4 ){
       td1.setAttribute('class','td4');
      }else{
       td1.setAttribute('class','td3');
      }
      td1.innerHTML=j;
      tr1.appendChild(td1);
    }
    
    t2.appendChild(tr1);
    
    

    
    var tr1=document.createElement('tr');
    var td1=document.createElement('td');
    td1.setAttribute('class','td2');
    td1.innerHTML='&nbsp;';
    tr1.appendChild(td1);
    
    for(var j=debut;j<i;j++){
      var td1=document.createElement('td');
      if(out[j][1]==1){
       td1.setAttribute('class','td2');
      }else if(out[j][1]==3  ){
       td1.setAttribute('class','td5');
      }else if( out[j][1]==4 ){
       td1.setAttribute('class','td4');
      }else{
       td1.setAttribute('class','td3');
      }
      td1.innerHTML=out[j][3];
      tr1.appendChild(td1);
    }
    
    t2.appendChild(tr1);
    
    
    
    
/*    
    var td1=document.createElement('td');
    td1.setAttribute('class','td2');
    td1.innerHTML=i;
    tr1.appendChild(td1);
*/    
    
    
    
    document.getElementById('resultat1').appendChild(t2);
    var sp1=document.createElement('span');
    var longueurDernierCaractere=out[out.length-1][1]==4?2:1;
    
    sp1.innerHTML='a.value.length='+a.value.length + ' , out.length=' + out.length + ' , dernier caract√®re:' + a.value.substr( a.value.length-longueurDernierCaractere,longueurDernierCaractere) ;
    document.getElementById('resultat1').appendChild(sp1);
    
    
    
    
/*    
    var a2fnc=arrayToFunctNoComment(b.value)
    var di1=document.createElement('div');
    if(a2fnc.status===true){
     di1.innerHTML='<hr  />'+a2fnc.value;
    }else{
     di1.innerHTML='<hr />'+a2fnc.message;
    }
    document.getElementById('resultat1').appendChild(di1);
*/    
    
    
    
    var a2fc=arrayToFunctWidthComment(b.value)
    var di2=document.createElement('pre');
    if(a2fc.status===true){
     
     di2.innerHTML='<hr />'+a2fc.value+''+(a2fc.value==a.value?'<br /><b style="color:green;">identiques :-)</b>':'')+'';
    }else{
     di2.innerHTML='<hr />'+a2fc.message;
    }
    document.getElementById('resultat1').appendChild(di2);
    
    
    var a2fn=arrayToFunctNormalize(b.value,false)
    var di3=document.createElement('pre');
    if(a2fn.status===true){
     
     di3.innerHTML='<hr />'+a2fn.value+''+(a2fn.value==a.value?'<br /><b style="color:green;">identiques :-)</b>':'<br /><b style="color:red;">diff√©rents :-(</b')+'';
    }else{
     di3.innerHTML='<hr />'+a2fn.message;
    }
    document.getElementById('resultat1').appendChild(di3);
    
    

    
    
//    child.addEventListener('click' , myFunct, false ); 
  
  }else{
    var sp1=document.createElement('span');
    sp1.style.color='red';
    sp1.innerHTML=b.message;
    document.getElementById('resultat1').appendChild(sp1);
  }

  
 
}
transform();
</script>
  
</body></html>